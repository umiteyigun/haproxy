#!/usr/bin/expect -f

# Arguments
if {[llength $argv] < 4} {
    puts stderr "Usage: certbot_dns_manual.expect <domain> <base_domain> <email> <session_dir>"
    exit 1
}

set domain [lindex $argv 0]
set base_domain [lindex $argv 1]
set email [lindex $argv 2]
set session_dir [lindex $argv 3]

set timeout -1

# Normalize session directory and ensure exists
file mkdir $session_dir

set certbot_work_dir "/app/config/certbot-work"
set certbot_logs_dir "/app/config/certbot-logs"

foreach dir [list $certbot_work_dir $certbot_logs_dir] {
    if {![file exists $dir]} {
        file mkdir $dir
    }
}

set challenge_file "$session_dir/challenge.json"
set result_file "$session_dir/result.json"
set log_file "$session_dir/certbot.log"
set continue_signal "$session_dir/continue"
set info_file "$session_dir/info.json"

# Remove old files if exist
foreach f [list $challenge_file $result_file $continue_signal $log_file] {
    if {[file exists $f]} {
        file delete -force $f
    }
}

# Simple JSON string escape
proc json_escape {str} {
    set escaped ""
    foreach char [split $str ""] {
        switch -- $char {
            "\"" {append escaped "\\\""}
            "\\" {append escaped "\\\\"}
            "\b" {append escaped "\\b"}
            "\f" {append escaped "\\f"}
            "\n" {append escaped "\\n"}
            "\r" {append escaped "\\r"}
            "\t" {append escaped "\\t"}
            default {append escaped $char}
        }
    }
    return $escaped
}

proc write_json_object {path dict} {
    set fh [open $path "w"]
    puts -nonewline $fh "{"
    set first 1
    foreach {key value} $dict {
        if {!$first} {
            puts -nonewline $fh ","
        }
        set first 0
        set k "\"$key\""
        if {[string match {__RAW__*} $value]} {
            set rawValue [string range $value 7 end]
            puts -nonewline $fh "\n  $k: $rawValue"
        } else {
            puts -nonewline $fh "\n  $k: \"[json_escape $value]\""
        }
    }
    puts $fh "\n}"
    close $fh
}

# Write session info
write_json_object $info_file [list domain $domain baseDomain $base_domain email $email]

# Build certbot command arguments
set certbot_cmd [list certbot certonly --manual \
    --config-dir /app/config/certbot \
    --work-dir $certbot_work_dir \
    --logs-dir $certbot_logs_dir \
    --preferred-challenges dns \
    --email $email \
    --agree-tos \
    --no-eff-email \
    --keep-until-expiring]

lappend certbot_cmd -d $domain
if {$base_domain ne $domain} {
    lappend certbot_cmd -d $base_domain
}

# Start certbot process
log_file -noappend $log_file
spawn {*}$certbot_cmd
set certbot_spawn_id $spawn_id

set success 0
set failure_message ""
set txt_name ""
set txt_value ""

while {1} {
    expect {
        -re {Please deploy a DNS TXT record under the name:\s+([^\r\n]+)\s+with the following value:\s+([^\r\n]+)\s+} {
            set raw_name [string trim $expect_out(1,string)]
            set raw_value [string trim $expect_out(2,string)]
            if {[string match *. $raw_name]} {
                set raw_name [string range $raw_name 0 end-1]
            }

            set txt_name $raw_name
            set txt_value $raw_value

            write_json_object $challenge_file [list txt_domain $txt_name txt_value $txt_value]
            puts "CHALLENGE_READY $txt_name"
            flush stdout

            while {![file exists $continue_signal]} {
                after 1000
            }
            file delete -force $continue_signal
            send "\r"
        }
        -exact {Are you OK with your IP being logged? (Y)es/(N)o:} {
            send "Y\r"
        }
        -re {Congratulations!|Successfully received certificate} {
            set success 1
            exp_continue
        }
        eof {
            break
        }
    }
}

set wait_status [wait -i $certbot_spawn_id]
set exit_code [lindex $wait_status 3]

if {$exit_code != 0 && $success == 0} {
    set failure_message "Certbot exited with code $exit_code"
}

set success_raw [expr {$success ? "true" : "false"}]
set exit_raw $exit_code

write_json_object $result_file [list \
    exitCode "__RAW__$exit_raw" \
    success "__RAW__$success_raw" \
    message $failure_message \
    txt_domain $txt_name \
    txt_value $txt_value]

puts "PROCESS_COMPLETE $exit_code"
exit $exit_code
